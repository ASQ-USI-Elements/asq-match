<link rel="import" href="../../polymer/polymer.html">

<link rel="import" href="../../asq-base/asq-base.html">
<link rel="import" href="../asq-match.html">
<link rel="import" href="../../paper-button/paper-button.html">

<!--
......

##### Example
    <asq-a-question>
      <div targets>
        <div target name="Long"><span>Long</span></div>
        <div target name="Short"><span>Short</span></div>
      </div>
      <div objects>
        <div object name="glas">Gl<b>a</b>s</div>
        <div object name="nudeln">N<b>u</b>deln</div>
        <div object name="platz">Pl<b>a</b>tz</div>
        <div object name="vier">v<b>i</b>er</div>
      </div>
    </asq-a-question>


@element asq-a-question
@group ASQ Elements
@blurb ...
@homepage http://github.com/ASQ_USI/a-question
-->
<polymer-element name="asq-a-question" attributes="mode targets objects interchangeable">
  <template>
    <style>
    section#show {
      margin: 0px auto;
      display: block;
      text-align: center;
    }
    </style>
    
    <asq-match id="match" mode="{{mode}}" on-asq-match="{{onMatch}}"></asq-match>
    
    <content id="items" select="*" ></content>
    <section id="show"></section>
    
  </template>

  <script>
  (function() {


    var p = {

      valueattr: 'name',

      // excludedLocalNames: '',

      targets: null,
      objects: null,

      itemsSelector: '',

      activateEvent: 'tap',

      // defaultExcludedLocalNames: 'template',

      mode: '1-m',
      // objects: [],


      created: function() {
        this.addEventListener('asq-match', this.onMatch, true);
      },

      ready: function() {
        this.activateListener = this.onTargetTap.bind(this);
        // this.itemFilter = this.filterItem.bind(this);
        this.observer = new MutationObserver(this.update.bind(this));
      },

      update: function() {

      },

      filterItem: function(node) {
        return !this._excludedNames[node.localName];
      },

      domReady: function() {
        this.unmathcedObjects = this.getUnmatchedObjects();
        // this.getTargets().forEach(function(el, index){
        //   el.addEventListener('click', this.onTargetTap.bind(this));
        // }, this);
        this.showNextObject();
      },

      targetsChanged: function(old, news) {
        if (old && typeof old === "object") {
          this.removeListener(old);
          this.observer.disconnect();
        }
        if (this.targets && typeof this.targets === "string") {
          var targets = this.parentNode.querySelector(this.targets);
          if ( targets ) {
            this.targets = targets;
            this.observer.observe(this.targets, {childList: true});
            for (var x of this.getTargets()) {
              // this.addListener(x);
              x.addEventListener('click', this.onTargetTap.bind(this));
            }
          }
        } else {
          // this.observer.observe(this.targets, {childList: true});
          // this.addListener(this.targets);
        }
      },

      objectsChanged: function(old) {
        if (old && typeof old === "object") {
          this.removeListener(old);
          this.observer.disconnect();
        }
        if (this.objects && typeof this.objects === "string") {
          var objects = this.parentNode.querySelector(this.objects);
          if ( objects ) {
            this.objects = objects;
            this.observer.observe(this.objects, {childList: true});
          }
        } else {
          this.observer.observe(this.objects, {childList: true});
        }
      },

      addListener: function(node) {
        Polymer.addEventListener(node, this.activateEvent, this.activateListener, true);
      },

      removeListener: function(node) {
        console.log('sss', node);
        Polymer.removeEventListener(node, this.activateEvent, this.activateListener);
      },

      onChangeObject: function(event) {
        console.log('onChangeObject', event.target);
        this.changeObject(event.target.parentNode);
        event.stopPropagation();
      },


      changeObject: function(object) {
        var targets = this.getTargets();
        var oldBucket = object.parentNode;
        if (!oldBucket || !targets || targets.length <= 1) return;

        var index = targets.indexOf(oldBucket);
        index = index+1 == targets.length ? 0 : index+1;
        var peerBucket = targets[index];

        this.match(peerBucket, object);
      },

      onTargetTap: function(e) {
        var target = e.currentTarget;
        var object = this.getCurrentTarget();
        if ( !object ) return;
        console.log(e.currentTarget, e.target);
        // add a small label onto the object, which is used to move the object over 
        // the targets
        var changeButton = document.createElement('i');
        changeButton.setAttribute('change', true);
        changeButton.textContent = '<>';
        object.appendChild(changeButton);

        changeButton.addEventListener('click', this.onChangeObject.bind(this), true);
        object.addEventListener('click', this.onMatchedObjectClick.bind(this));
        
        this.match(target, object);
        this.showNextObject();
      },



      onMatchedObjectClick: function(event) {
        console.log('onChange', event);

        event.stopPropagation();
      },


      getCurrentTarget: function() {
        var targets = this.$.show.childNodes.array().filter(function(e) {
            return e.nodeType == 1 && e.hasAttribute('object');
        });
        if ( targets.length > 0 ) return targets[0];
        else return null;
      },

      // 
      showNextObject: function() {
        var objects = this.getUnmatchedObjects();
        if ( objects.length == 0 ) this.$.show.innerHtml = '';
        else this.$.show.appendChild(objects.pop());
      },

      onMatch: function(e) {
        // this.prettyPrint();
      },


      isMatch: function(k, v) {
        return this.$.match.isMatch(k.getAttribute("name"), v.getAttribute("name"));
      },

      /**
       * @method match
       * @param  {Object} k target
       * @param  {Object} v object
       */
      match: function(k, v) {
        k.appendChild(v);
        this.$.match.match(k.getAttribute("name"), v.getAttribute("name"));
      },




      /**
       * The `submit` method returns an object that respresents the submission of this question. The object has the following structure:

           {
              questionUid: this.uid, 
              timestamp: new Date(),

              // Array of the result of submit() called for each option of the question
              submission: [] 
           }
       * Only enabled when the `role` of the element is <b>viewer</b>.
       *
       * @method submit
       */
      submit: function() {
        if ( this.role !== this.roles.VIEWER ) {
          return;
        }

        var submission = this.$.match.getMatches();

        return {
          questionUid: this.uid,
          timestamp: new Date(),
          submission: submission
        };
      },


      getTargets: function() {
        var targets = [];
        this.targets.childNodes.array().forEach(function(e) {
          e.nodeType == 1 && e.hasAttribute('target') && targets.push(e);
        });
        return targets;
      },

      /**
       * @method getUnmatchedObjects Get all unmatched objects.
       * @return {array} UnmatchedObjects
       */
      getUnmatchedObjects: function() {
        var objects = [];
        this.objects.childNodes.array().forEach(function(e) {
            e.nodeType == 1 && e.hasAttribute('object') && objects.push(e);
        });
        return objects.reverse();

      },

      prettyPrint: function() {
        var ms = this.$.match.getMatches();
        console.log(' - - - - match', ms.length, ' - - - -');
        ms.forEach(function(k, index){
          console.log('  ', index, ' : ' , k.from, k.value);
        });
        console.log(' ');
      },

      unbindEvent: function() {
        // TODO
        console.log('unbindEvent');
        this.getTargets().forEach(function(el, index){
          el.removeEventListener('click', this.onTargetTap.bind(this));
        }, this);
      },

    }

    ASQ.asqify(p, true);
    Polymer('asq-a-question', p);

  })();
  </script>
</polymer-element>
