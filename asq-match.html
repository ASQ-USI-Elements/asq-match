<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../asq-base/asq-base.html">

<polymer-element name="asq-match" attributes="mode" hidden>

  <script>
  (function() {

    var modes = {
      SINGLE: "single",
      O2M: "one_to_many",
      M2O: "many_to_one",
      M2M: 'many_to_many'
    };

    var proto = {
      /**
       * Des...
       *
       * @attribute realtion
       * @type string
       * @default "1-1"
       */
      mode: "1-1",

      modeState: modes.SINGLE,


      ready: function() {
        this.modeChanged();
        this.clear();
      },

      clear: function() {
        this.matching = [];
      },

      /**
       * Retrieves all the matchings 
       * @method getMatches      
       * @returns Returns the matching(s).
      */
      getMatches: function(from) {
        if ( from == null ) {
          return this.matching;
        } else {
          var index = this.lookup(from);
          if ( index >= 0) {
            return this.matching[index].value
          } else {
            return null;
          }
        }
      },

      getMatchesItem: function(from) {
        var index = this.lookup(from);
          if ( index >= 0) {
            return this.matching[index];
          } else {
            return null;
          }
      },

      deleteItem: function(from) {
        var i = this.lookup(from);
        if ( i >= 0) {
          this.matching.splice(i, 1);
        } 
      },

      /**
       * Indicates if there is a matching between `from` and `to`.
       * @method isSelected
       * @param {any} from ...
       * @param {any} to ...
       * @returns Returns true if there is matching between `from` and `to`.
      */
      isMatch: function(from, to) {
        var i = this.lookup(from);
        if ( i >= 0) {
          return this.matching[i].value.indexOf(to) >= 0 ? true : false;
        } else {
          return false;
        }
      },

      setMatched: function(from, to, isMatch) {
        if ( from !== undefined && from !== null && to !== undefined && to !== null) {
          if ( isMatch ) {
            var m = this.getMatchesItem(from);
            m = m == null ? {from: from, value: []} : m;
            m.value.push(to);
            this.deleteItem(from);
            this.matching.push(m);
          } else {
            var i = this.lookup(from);
            if (i >= 0) {
              if ( Array.isArray(to) ) {
                console.log('isArray');
              } else {
                var j = this.matching[i].value.indexOf(to);
                this.matching[i].value.splice(j, 1);
              }
            }
          }
          this.fire("asq-match", {isMatch: isMatch, from: from, to: to});
        }
      },

      match: function(from, to) {
        if ( from == null || from == undefined || to == null || to == undefined ) {
          return;
        }
        // if (this.isMatch(from, to)) return;

        if ( this.modeState == modes.O2M  ) {
          if ( this.count(to) > 0 ) {
            var xs = this.getFromsBy(to);
            xs.forEach(function(e){ this.setMatched(e, to, false);}, this);
          } 
        } else if (this.modeState == modes.M2O){
          if (this.existMatchesFrom(from)) {
            this.setMatched(from, this.getMatches(from)[0], false);
          } 
        } else if ( this.modeState == modes.SINGLE ) {
          if (this.getMatches(from) ) {
            this.setMatched(from, this.getMatches(from)[0], false);
          }
        }


        this.toggle(from, to); 
      },

      /**
       * 
       * @method getFromsBy
       * @param  {[type]} to [description]
       * @return {[type]}    [description]
       */
      getFromsBy: function(to) {
        var xs = [];
        this.matching.forEach(function(e) {
          e.value.forEach(function(t) {
            if ( to == t ) {
              xs.push(e.from);
            }
          })
        })
        return xs;
      },

      /**
       * 
       * @param  {[type]} to [description]
       * @return {[type]}    [description]
       */
      count: function(to) {
        var count = 0;
        this.matching.forEach(function(e) {
          e.value.forEach(function(f) {
            if ( f == to ) {
              count++;
            }
          })
        });
        return count;
      },

      toggle: function(from, to) {
        this.setMatched(from, to, !this.isMatch(from ,to));
      },

      lookup: function(from) {
        var index = -1;
        this.matching.forEach(function(e, i) {
          if ( e.from == from ) {
            index = i;
          }
        });
        return index;
      },

      existMatchesFrom: function(from) {
        return this.lookup(from) >= 0 ? true : false;
      },

      existsValue: function(to) {
        return this.count(to) > 0 ? true : false;
      },

      existsKey: function(from) {
        return this.lookup(from) >= 0 ? true : false;
      },

      modeChanged: function() {
        switch(this.mode) {
          case "1-1":
          case "single":
            this.modeState = modes.SINGLE;
            break;
          case "1-n":
          case "1-m":
            this.modeState = modes.O2M;
            break;
          case "n-1":
          case "m-1":
            this.modeState = modes.M2O;
            break;
          case "m-n":
          case "n-m":
          case "multi":
            this.modeState = modes.M2M;
            break;
          default:
            this.modeState = SINGLE;
            this.mode = '1-1';
        } 
      }

    }

    Polymer.mixin(proto, ASQ.ElementTypeMixin);
    Polymer('asq-match', proto);
  })();
  </script>
</polymer-element>
