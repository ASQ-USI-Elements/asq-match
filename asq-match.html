<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../asq-base/asq-base.html">

<polymer-element name="asq-match" attributes="mode" hidden>

  <script>
  (function() {

    var modes = {
      SINGLE: "single",
      O2M: "one_to_many",
      M2O: "many_to_one",
      M2M: 'many_to_many'
    };

    var proto = {
      /**
       * Des...
       *
       * @attribute realtion
       * @type string
       * @default "1-1"
       */
      mode: '',

      modeState: modes.SINGLE,

      created: function() {
        this.mode = '1-1';
      },


      ready: function() {
        
        this.clear();
      },

      clear: function() {
        this.matches = [];
      },

      /**
       * Retrieves all the matchings 
       * @method getMatches      
       * @returns Returns the matching(s).
      */
      getMatches: function(from) {
        if ( from == null ) {
          return this.matches;
        } else {
          var index = this.lookup(from);
          if ( index >= 0) {
            return this.matches[index].value
          } else {
            return null;
          }
        }
      },

      deleteItem: function(from) {
        var i = this.lookup(from);
        if ( i >= 0) {
          this.matches.splice(i, 1);
        } 
      },

      /**
       * Indicates if there is a matching between `from` and `to`.
       * @method isSelected
       * @param {any} from ...
       * @param {any} to ...
       * @returns Returns true if there is matching between `from` and `to`.
      */
      isMatch: function(from, to) {
        var i = this.lookup(from);
        if ( i >= 0) {
          return this.matches[i].value.indexOf(to) >= 0 ? true : false;
        } else {
          return false;
        }
      },

      setMatched: function(from, to, isMatch) {
        if ( from !== undefined && from !== null && to !== undefined && to !== null) {
          if ( isMatch ) {
            var index = this.lookup(from);
            var m = index >= 0 ? this.matches[index] : {from: from, value: []};
            m.value.push(to);
            // delete old item first then add a new one
            this.deleteItem(from);
            this.matches.push(m);
          } else {
            var i = this.lookup(from);
            if (i >= 0) {
              if ( Array.isArray(to) ) {
                console.log('isArray');
              } else {
                var j = this.matches[i].value.indexOf(to);
                this.matches[i].value.splice(j, 1);
              }
            }
          }
          this.fire("asq-match", {isMatch: isMatch, from: from, to: to});
        }
      },

      match: function(from, to) {
        if ( from == null || from == undefined || to == null || to == undefined ) {
          return;
        }

        if ( this.modeState == modes.O2M  ) {
          if ( !this.isMatch(from, to) && this.count(to) > 0) {
            var xs = this.getFromsByTo(to);
            xs.forEach(function(e){ this.setMatched(e, to, false);}, this);
          } 

        } else if (this.modeState == modes.M2O){
          if (this.existMatchesFrom(from) && !this.isMatch(from, to)) {
            this.setMatched(from, this.getMatches(from)[0], false);
          } 

        } else if ( this.modeState == modes.SINGLE ) {
          if ( ! this.isMatch(from, to) ) {
            if (this.existMatchesFrom(from) ) {
                this.setMatched(from, this.getMatches(from)[0], false);
            }
            var fs = this.getFromsByTo(to);
            if (fs.length > 0) {
              this.toggle(fs[0], to);
            }
          }
        }
        this.toggle(from, to); 
        
      },

      /**
       * 
       * @method getFromsByTo
       * @param  {[type]} to [description]
       * @return {[type]}    [description]
       */
      getFromsByTo: function(to) {
        var xs = [];
        this.matches.forEach(function(e) {
          e.value.forEach(function(t) {
            if ( to == t ) {
              xs.push(e.from);
            }
          })
        })
        return xs;
      },

      /**
       * 
       * @param  {[type]} to [description]
       * @return {[type]}    [description]
       */
      count: function(to) {
        var count = 0;
        this.matches.forEach(function(e) {
          e.value.forEach(function(f) {
            if ( f == to ) {
              count++;
            }
          })
        });
        return count;
      },

      toggle: function(from, to) {
        this.setMatched(from, to, !this.isMatch(from ,to));
      },

      lookup: function(from) {
        var index = -1;
        this.matches.forEach(function(e, i) {
          if ( e.from == from ) {
            index = i;
          }
        });
        return index;
      },

      existMatchesFrom: function(from) {
        if ( this.lookup(from) < 0 ) return false;
        return this.getMatches(from).length > 0 ? true : false;
      },

      existsValue: function(to) {
        return this.count(to) > 0 ? true : false;
      },

      modeChanged: function() {
        switch(this.mode) {
          case "1-1":
          case "single":
            this.modeState = modes.SINGLE;
            break;
          case "1-n":
          case "1-m":
            this.modeState = modes.O2M;
            break;
          case "n-1":
          case "m-1":
            this.modeState = modes.M2O;
            break;
          case "m-n":
          case "n-m":
          case "multi":
            this.modeState = modes.M2M;
            break;
          default:
            this.modeState = SINGLE;
            this.mode = '1-1';
        } 
      }

    }

    Polymer.mixin(proto, ASQ.ElementTypeMixin);
    Polymer('asq-match', proto);
  })();
  </script>
</polymer-element>
